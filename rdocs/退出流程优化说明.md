# 退出流程优化说明

## 问题描述

在程序退出时，出现以下错误：

```
2025/12/26 23:50:48 [ERROR] ❌ 数据库写入失败: 保存 order_canceled 失败: sql: database is closed
```

## 问题原因

退出时的关闭顺序存在问题：

1. **原有流程**：
   - 撤销所有订单（触发 `order_canceled` 事件）
   - 立即取消 context（停止所有协程，包括事件处理协程）
   - 停止各个组件
   - 停止存储服务（关闭数据库）
   - 关闭日志存储

2. **问题所在**：
   - 撤单操作会产生 `order_canceled` 事件
   - 事件被发送到事件队列等待处理
   - `cancel()` 立即停止事件处理协程
   - 但队列中的事件还未处理完
   - 存储服务关闭数据库
   - 事件处理协程尝试写入数据库时，数据库已关闭

## 修复方案

### 1. 调整关闭顺序

**新的关闭流程**（按优先级）：

```
第一优先级：撤销所有订单（最重要！）
  ↓
第二优先级：优雅停止各个组件
  - 停止价格监控
  - 停止订单流
  - 停止风控监视器
  - 停止动态调整器
  - 停止趋势检测器
  - 停止策略管理器
  - 停止看门狗监控
  ↓
第三优先级：取消 context（停止事件处理协程）
  ↓
等待 500ms（让事件队列处理完毕）
  ↓
第四优先级：停止存储服务（关闭数据库）
  ↓
等待 200ms（让存储服务完成最后的写入）
  ↓
打印最终状态
  ↓
关闭文件日志
  ↓
关闭日志存储
```

### 2. 改进存储服务

#### 2.1 添加停止状态标记

```go
type StorageService struct {
    // ... 其他字段
    stopped bool
    stopMu  sync.Mutex
}
```

#### 2.2 改进 Stop() 方法

```go
func (ss *StorageService) Stop() {
    // 1. 检查是否已停止（防止重复调用）
    ss.stopMu.Lock()
    if ss.stopped {
        ss.stopMu.Unlock()
        return
    }
    ss.stopped = true
    ss.stopMu.Unlock()

    // 2. 取消 context（通知 processEvents 协程退出）
    if ss.cancel != nil {
        ss.cancel()
    }

    // 3. 等待 processEvents 协程处理完队列中的事件
    time.Sleep(100 * time.Millisecond)

    // 4. 最后刷新缓冲区（确保所有事件都被处理）
    ss.flush()

    // 5. 关闭存储（关闭数据库连接）
    if ss.storage != nil {
        ss.storage.Close()
    }
}
```

#### 2.3 改进 Save() 方法

```go
func (ss *StorageService) Save(eventType string, data interface{}) {
    if ss.storage == nil {
        return
    }

    // 检查服务是否已停止
    ss.stopMu.Lock()
    stopped := ss.stopped
    ss.stopMu.Unlock()

    if stopped {
        // 服务已停止，不再接受新事件
        return
    }

    // ... 后续逻辑
}
```

#### 2.4 改进 batchSave() 方法

```go
func (ss *StorageService) batchSave(events []*storageEvent) error {
    // 检查存储是否可用
    if ss.storage == nil {
        return fmt.Errorf("存储服务未初始化")
    }

    // 使用事务批量写入
    for _, event := range events {
        // ... 保存逻辑

        if err != nil {
            // 检查是否是数据库关闭错误
            if err.Error() == "sql: database is closed" {
                return fmt.Errorf("数据库已关闭，停止保存")
            }
            return fmt.Errorf("保存 %s 失败: %w", event.eventType, err)
        }
    }

    return nil
}
```

### 3. 改进 SQLite 存储

#### 3.1 添加关闭状态标记

```go
type SQLiteStorage struct {
    db     *sql.DB
    closed bool
}
```

#### 3.2 改进 Close() 方法

```go
func (s *SQLiteStorage) Close() error {
    if s.closed {
        return nil
    }
    s.closed = true
    return s.db.Close()
}
```

## 修复效果

1. **消除错误**：不再出现 "sql: database is closed" 错误
2. **数据完整性**：确保所有事件都被正确保存到数据库
3. **优雅退出**：各个组件按正确的依赖关系顺序关闭
4. **防止重复关闭**：添加状态标记，防止重复关闭导致的错误

## 影响范围

- `main.go`：调整关闭顺序
- `storage/storage.go`：改进存储服务的停止逻辑
- `storage/sqlite.go`：添加关闭状态检查

## 测试建议

1. 正常退出测试（Ctrl+C）
2. 有订单时退出测试（确保撤单事件被正确保存）
3. 高负载时退出测试（确保事件队列被正确处理）
4. 多次快速启动/停止测试（确保不会出现资源泄漏）

## 注意事项

1. **等待时间**：
   - 取消 context 后等待 500ms，让事件队列处理完毕
   - 停止存储服务后等待 200ms，让最后的写入完成
   - 这些时间可以根据实际情况调整

2. **事件丢失**：
   - 在服务停止后，新的事件会被直接丢弃（不会记录警告）
   - 这是正常行为，因为系统正在关闭

3. **数据库关闭**：
   - SQLite 使用 WAL 模式，关闭时会自动 checkpoint
   - 确保在关闭前所有事务都已提交

## 相关文件

- `main.go`：主程序退出流程
- `storage/storage.go`：存储服务实现
- `storage/sqlite.go`：SQLite 存储实现
- `event/event.go`：事件系统

## 版本信息

- 修复版本：v3.3.1+
- 修复日期：2025-12-26
- 修复人：AI Assistant

