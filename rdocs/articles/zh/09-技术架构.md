# 技术架构详解

> **版本**: v3.3.2  
> **更新时间**: 2025-01-27

---

## 目录

1. [整体架构](#整体架构)
2. [核心模块](#核心模块)
3. [数据流](#数据流)
4. [并发模型](#并发模型)
5. [设计模式](#设计模式)
6. [技术栈](#技术栈)

---

## 整体架构

### 架构分层

```
┌─────────────────────────────────────────┐
│         应用层 (main.go)                │
│   组件编排、生命周期管理、适配器          │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────┐         ┌──────▼─────┐
│ Config │         │  Logger    │
│ (配置) │         │  (日志)   │
└────────┘         └────────────┘
    │
    │
┌───▼────────────────────────────────────┐
│      业务逻辑层                         │
│  ┌──────────┐  ┌──────────┐           │
│  │ Position │  │  Order   │           │
│  │ (仓位)   │  │  (订单)  │           │
│  └──────────┘  └──────────┘           │
│  ┌──────────┐  ┌──────────┐           │
│  │ Monitor  │  │  Safety  │           │
│  │ (监控)   │  │  (风控)  │           │
│  └──────────┘  └──────────┘           │
└───┬────────────────────────────────────┘
    │
┌───▼────────────────────────────────────┐
│      抽象接口层 (exchange/)             │
│      IExchange 统一接口                │
└───┬────────────────────────────────────┘
    │
┌───▼────────────────────────────────────┐
│      具体实现层                         │
│  binance/  bitget/  gate/  ...        │
└────────────────────────────────────────┘
```

### 核心设计原则

1. **单一价格源原则**
   - 全局唯一的价格流（PriceMonitor）
   - WebSocket 是唯一的价格来源
   - 所有组件通过统一接口获取价格

2. **订单流优先原则**
   - 先启动订单流，再下单
   - 避免错过成交推送

3. **接口抽象原则**
   - 使用接口统一不同交易所的差异
   - 通过适配器模式实现接口转换

4. **槽位锁定机制**
   - 每个价格点对应一个槽位
   - 槽位状态机：FREE → PENDING → LOCKED
   - 防止并发重复下单

---

## 核心模块

### 1. Exchange Layer（交易所抽象层）

**职责：**
- 统一不同交易所的 API 差异
- 提供统一的接口抽象
- 管理 WebSocket 连接

**设计模式：**
- **接口模式**：`IExchange` 统一接口
- **工厂模式**：`NewExchange()` 创建实例
- **适配器模式**：`wrapper_*.go` 包装实现

**核心接口：**
```go
type IExchange interface {
    // 订单操作
    PlaceOrder(ctx, req) (*Order, error)
    BatchPlaceOrders(ctx, orders) ([]*Order, bool)
    CancelOrder(ctx, symbol, orderID) error
    
    // 账户查询
    GetAccount(ctx) (*Account, error)
    GetPositions(ctx, symbol) ([]*Position, error)
    
    // WebSocket
    StartPriceStream(ctx, symbol, callback)
    StartOrderStream(ctx, callback)
    StartKlineStream(ctx, symbols, interval, callback)
}
```

### 2. Price Monitor（价格监控）

**职责：**
- 全局唯一的价格流
- 实时接收 WebSocket 价格推送
- 定期推送价格变化到业务层

**核心设计：**
```go
type PriceMonitor struct {
    lastPrice     atomic.Value  // 原子操作存储价格
    lastPriceStr  atomic.Value  // 字符串格式（用于精度检测）
    priceChangeCh chan PriceChange  // 价格变化通道
    latestPriceChange atomic.Value   // 最新价格变化
}
```

**工作流程：**
```
交易所 WebSocket
    ↓
updatePrice() (收到价格推送)
    ↓
atomic.Value.Store() (原子存储)
    ↓
periodicPriceSender() (定期发送)
    ↓
priceChangeCh (channel)
    ↓
业务层监听
```

### 3. Super Position Manager（超级槽位管理器）

**职责：**
- 管理所有网格点的订单和持仓
- 实现槽位（Slot）系统
- 处理价格变化时的订单调整

**核心数据结构：**
```go
type InventorySlot struct {
    Price float64  // 槽位价格
    
    // 持仓状态
    PositionStatus string  // EMPTY/FILLED
    PositionQty    float64
    
    // 订单状态
    OrderID        int64
    ClientOID      string
    OrderSide      string  // BUY/SELL
    OrderStatus    string  // NOT_PLACED/PLACED/FILLED/CANCELED
    
    // 锁定机制
    SlotStatus string  // FREE/PENDING/LOCKED
    
    mu sync.RWMutex  // 槽位锁
}
```

**槽位生命周期：**
```
FREE (空闲)
  ↓ 下单
PENDING (等待下单确认)
  ↓ 下单成功
LOCKED (已锁定，有活跃订单)
  ↓ 买单成交
FILLED (有持仓，等待卖出)
  ↓ 卖单成交
FREE (回到初始状态)
```

### 4. Order Executor（订单执行器）

**职责：**
- 执行订单下单、撤单操作
- 实现限流和重试机制
- PostOnly 降级处理

**核心功能：**
```go
type ExchangeOrderExecutor struct {
    exchange    exchange.IExchange
    rateLimiter *rate.Limiter  // 限流器
}

// 限流：25单/秒，突发30
// 重试：最多5次
// PostOnly降级：连续失败3次后降级
```

### 5. Safety & Risk Control（安全风控）

**模块组成：**
- **safety.go**: 启动前安全检查
- **risk_monitor.go**: 主动风控监控
- **reconciler.go**: 持仓对账
- **order_cleaner.go**: 订单清理

**风控流程：**
```
启动前检查
  ↓
运行时监控（K线成交量异常检测）
  ↓
触发风控 → 撤销所有买单 → 暂停交易
  ↓
市场恢复 → 恢复交易
```

---

## 数据流

### 价格流

```
交易所 WebSocket (价格推送)
    ↓
PriceMonitor.updatePrice()
    ↓
atomic.Value.Store() (原子存储)
    ↓
periodicPriceSender() (定期发送，50ms间隔)
    ↓
priceChangeCh (channel, 容量10)
    ↓
main.go 价格监听协程
    ↓
风控检查 (RiskMonitor.IsTriggered)
    ├── ❌ 触发 → CancelAllBuyOrders(), 跳过 AdjustOrders
    └── ✅ 正常 → SuperPositionManager.AdjustOrders()
```

### 订单流

```
交易所 WebSocket (订单更新)
    ↓
main.go 回调函数
    ↓
反射提取字段 (解决匿名结构体问题)
    ↓
position.OrderUpdate
    ↓
SuperPositionManager.OnOrderUpdate()
    ├── 匹配槽位 (通过 ClientOrderID 或 OrderID)
    ├── 更新槽位状态
    ├── FILLED → 创建卖单
    └── CANCELED → 重置槽位
```

### 交易逻辑流

```
价格变化
    ↓
AdjustOrders(newPrice)
    ↓
遍历所有槽位 (sync.Map.Range)
    ↓
┌─────────────────────────────────┐
│ 槽位类型判断                    │
├─────────────────────────────────┤
│ 1. 空槽位 → 检查是否在买入窗口  │
│    → 下买单                     │
│                                 │
│ 2. 有买单 → 检查是否超出窗口    │
│    → 撤单                       │
│                                 │
│ 3. 有持仓 → 检查是否有卖单      │
│    → 无卖单 → 下卖单            │
│                                 │
│ 4. 有卖单 → 检查是否需要调价    │
│    → 撤单并重新下单             │
└─────────────────────────────────┘
```

---

## 并发模型

### Goroutine 列表

```
main.go 启动的协程:
1. priceMonitor.Start()          # 价格 WebSocket
2. ex.StartOrderStream()          # 订单 WebSocket
3. riskMonitor.Start()            # 风控 K线 WebSocket
4. reconciler.Start()             # 定期对账（每5分钟）
5. orderCleaner.Start()           # 定期清理（每60秒）
6. 价格变化监听 (main goroutine)  # 监听 priceChangeCh
7. 定期打印状态                   # 每1分钟
```

### Channel 使用

**价格变化 Channel：**
```go
priceChangeCh chan PriceChange  // 容量: 10

// 定期推送价格变化
select {
case pm.priceChangeCh <- *latest:
default: // channel 满了，跳过
}
```

**设计思想：**
- 使用缓冲 channel，避免阻塞
- 定期推送，降低负载
- 非阻塞发送，避免丢失

### 同步原语

**1. sync.Map - 槽位存储**
```go
type SuperPositionManager struct {
    slots sync.Map  // 支持并发读写
}

// 使用
spm.slots.Store(price, slot)
slot, _ := spm.slots.Load(price)
```

**2. sync.RWMutex - 细粒度锁**
```go
type SuperPositionManager struct {
    mu sync.RWMutex  // 全局锁
}

type InventorySlot struct {
    mu sync.RWMutex  // 槽位锁
}
```

**3. atomic.Value - 原子操作**
```go
type PriceMonitor struct {
    lastPrice atomic.Value  // float64
}

// 写入
pm.lastPrice.Store(price)

// 读取
price := pm.lastPrice.Load().(float64)
```

### 并发安全性

**高风险操作保护：**

1. **槽位并发修改**
   - 风险：价格变化协程 vs 订单更新回调
   - 保护：槽位锁 + SlotStatus 状态机

2. **订单重复下单**
   - 风险：AdjustOrders 快速调用
   - 保护：SlotStatus = PENDING 锁定

3. **价格读取**
   - 风险：多个协程同时读取
   - 保护：atomic.Value（无锁）

---

## 设计模式

### 1. 工厂模式（Factory Pattern）

**应用场景：** 创建交易所实例

```go
func NewExchange(cfg *config.Config) (IExchange, error) {
    switch cfg.App.CurrentExchange {
    case "binance":
        return createBinanceExchange(cfg)
    case "bitget":
        return createBitgetExchange(cfg)
    }
}
```

### 2. 适配器模式（Adapter Pattern）

**应用场景：** 接口转换

```go
type exchangeExecutorAdapter struct {
    executor *order.ExchangeOrderExecutor
}

func (a *exchangeExecutorAdapter) PlaceOrder(req *position.OrderRequest) (*position.Order, error) {
    // 转换类型并调用
    orderReq := convertRequest(req)
    ord, err := a.executor.PlaceOrder(orderReq)
    return convertOrder(ord), err
}
```

### 3. 观察者模式（Observer Pattern）

**应用场景：** 价格变化通知

```go
type PriceMonitor struct {
    priceChangeCh chan PriceChange
}

// 订阅者订阅价格变化
func (pm *PriceMonitor) Subscribe() <-chan PriceChange {
    return pm.priceChangeCh
}
```

### 4. 状态模式（State Pattern）

**应用场景：** 槽位状态管理

```go
// 槽位状态机
const (
    SlotStatusFree    = "FREE"
    SlotStatusPending = "PENDING"
    SlotStatusLocked  = "LOCKED"
)

// 状态转换
FREE → PENDING → LOCKED → FREE
```

---

## 技术栈

### 编程语言

- **Go 1.21+**
  - 高性能并发
  - 优秀的 WebSocket 支持
  - 丰富的标准库

### 核心依赖

- **gorilla/websocket**: WebSocket 客户端
- **golang.org/x/time/rate**: 限流器
- **gopkg.in/yaml.v3**: YAML 配置解析
- **github.com/mattn/go-sqlite3**: SQLite 数据库

### 架构特点

1. **模块化设计**
   - 各模块职责清晰
   - 易于维护和测试
   - 支持独立开发

2. **接口抽象**
   - 支持多交易所
   - 易于扩展
   - 业务逻辑与实现解耦

3. **并发安全**
   - 细粒度锁
   - 原子操作
   - 无死锁设计

4. **实时性**
   - WebSocket 驱动
   - 毫秒级响应
   - 事件驱动架构

5. **可靠性**
   - 多层风控
   - 自动对账
   - 错误重试

---

## 关键技术实现

### 1. WebSocket 连接管理

**重连机制：**
```go
func (ws *WebSocket) connect() error {
    for {
        conn, err := dialWebSocket()
        if err != nil {
            time.Sleep(reconnectDelay)
            continue
        }
        // 启动心跳和消息处理
        return nil
    }
}
```

### 2. 精度处理

**自动获取精度：**
```go
func (a *Adapter) initialize() error {
    info, err := a.client.GetExchangeInfo()
    a.priceDecimals = info.PricePrecision
    a.quantityDecimals = info.QuantityPrecision
    return nil
}
```

### 3. 订单ID生成

**自定义订单ID：**
```go
func GenerateClientOrderID(prefix string) string {
    timestamp := time.Now().UnixNano() / int64(time.Millisecond)
    random := rand.Intn(10000)
    return fmt.Sprintf("%s_%d_%04d", prefix, timestamp, random)
}
```

---

## 扩展性分析

### 添加新交易所

**步骤：**
1. 实现交易所适配器
2. 实现 WebSocket
3. 实现包装器
4. 注册到工厂

### 添加新功能

**示例：** 添加止损功能
1. 扩展配置
2. 实现逻辑
3. 集成到主流程

---

## 总结

### 架构优势

1. **高性能**: Go 语言 + WebSocket 实时数据流
2. **高可靠**: 多层风控 + 智能仓位管理
3. **易扩展**: 接口抽象 + 工厂模式
4. **并发安全**: 细粒度锁 + 原子操作

### 设计思想

1. **单一职责**: 每个模块只负责一个功能
2. **依赖倒置**: 依赖接口而非具体实现
3. **开闭原则**: 对扩展开放，对修改关闭
4. **接口隔离**: 使用子集接口避免循环依赖

---

## 下一步

- 📊 [运行赚钱的基本逻辑](./08-运行赚钱的基本逻辑.md) - 了解盈利原理
- 🔄 [与其他系统对比](./10-与其他系统对比.md) - 对比其他量化系统
- 🏦 [与做市商对比](./11-与做市商对比.md) - 对比传统做市商

---

*技术架构是系统稳定运行的基础，理解架构有助于更好地使用和扩展系统。*

